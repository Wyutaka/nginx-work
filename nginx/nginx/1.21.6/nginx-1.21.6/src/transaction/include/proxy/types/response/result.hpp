#pragma once

#include <string_view>

/*
0x84
0x00
0x00,0x00
0x08
0x00,0x00,0x02,0x44
0x00,0x00,0x00,0x02 // Rows
0x00,0x00,0x00,0x01  // flags 1
0x00,0x00,0x00,0x12  // column count
0x00,0x06 // len(ksname)
0x73,0x79,0x73,0x74,0x65,0x6d // ksname
0x00,0x05 // len(tablename)
0x6c,0x6f,0x63,0x61,0x6c // tablename
// column 1
0x00,0x03
0x6b,0x65,0x79
0x00,0x0d  // varchar
// column 2
0x00,0x0c
0x62,0x6f,0x6f,0x74,0x73,0x74,0x72,0x61,0x70,0x70,0x65,0x64
0x00,0x0d // varchar
// column 3
0x00,0x11
0x62,0x72,0x6f,0x61,0x64,0x63,0x61,0x73,0x74,0x5f,0x61,0x64,0x64,0x72,0x65,0x73,0x73
0x00,0x10 // Inet
// column 4
0x00,0x0c
0x63,0x6c,0x75,0x73,0x74,0x65,0x72,0x5f,0x6e,0x61,0x6d,0x65
0x00,0x0d // varchar
// column 5
0x00,0x0b
0x63,0x71,0x6c,0x5f,0x76,0x65,0x72,0x73,0x69,0x6f,0x6e
0x00,0x0d // varchar
// column 6
0x00,0x0b
0x64,0x61,0x74,0x61,0x5f,0x63,0x65,0x6e,0x74,0x65,0x72
0x00,0x0d // varchar
// column 7
0x00,0x11
0x67,0x6f,0x73,0x73,0x69,0x70,0x5f,0x67,0x65,0x6e,0x65,0x72,0x61,0x74,0x69,0x6f,0x6e
0x00,0x09 // int
// column 8
0x00,0x07
0x68,0x6f,0x73,0x74,0x5f,0x69,0x64
0x00,0x0c // uuid
// column 9
0x00,0x0e
0x6c,0x69,0x73,0x74,0x65,0x6e,0x5f,0x61,0x64,0x64,0x72,0x65,0x73,0x73
0x00,0x10 // inet
// column 10 (a)
0x00,0x17
0x6e,0x61,0x74,0x69,0x76,0x65,0x5f,0x70,0x72,0x6f,0x74,0x6f,0x63,0x6f,0x6c,0x5f,0x76,0x65,0x72,0x73,0x69,0x6f,0x6e
0x00,0x0d // varchar
// column 11 (b)
0x00,0x0b
0x70,0x61,0x72,0x74,0x69,0x74,0x69,0x6f,0x6e,0x65,0x72
0x00,0x0d // varchar
// column 12 (c)
0x00,0x04
0x72,0x61,0x63,0x6b
0x00,0x0d // varchar
// column 13 (d)
0x00,0x0f
0x72,0x65,0x6c,0x65,0x61,0x73,0x65,0x5f,0x76,0x65,0x72,0x73,0x69,0x6f,0x6e
0x00,0x0d // varchar
// column 14 (e)
0x00,0x0b
0x72,0x70,0x63,0x5f,0x61,0x64,0x64,0x72,0x65,0x73,0x73
0x00,0x10 // inet
// column 15 (f)
0x00,0x0e
0x73,0x63,0x68,0x65,0x6d,0x61,0x5f,0x76,0x65,0x72,0x73,0x69,0x6f,0x6e
0x00,0x0c // uuid
// column 16 (10)
0x00,0x0e
0x74,0x68,0x72,0x69,0x66,0x74,0x5f,0x76,0x65,0x72,0x73,0x69,0x6f,0x6e
0x00,0x0d // varchar
// column 17 (11)
0x00,0x06
0x74,0x6f,0x6b,0x65,0x6e,0x73,0x00,0x22
0x00,0x0d // varchar
// column 18 (12)
0x00,0x0c
0x74,0x72,0x75,0x6e,0x63,0x61,0x74,0x65,0x64,0x5f,0x61,0x74
0x00,0x21 // map<uuid, blob>
0x00,0x0c //  uuid
0x00,0x03 //  blob
0x00,0x00,0x00,0x01

0x00,0x00,0x00,0x05
0x6c,0x6f,0x63,0x61,0x6c

0x00,0x00,0x00,0x09
0x43,0x4f,0x4d,0x50,0x4c,0x45,0x54,0x45,0x44

0x00,0x00,0x00,0x04
0xc0,0xa8,0x0b,0x3c // 192.168.11.60

0x00,0x00,0x00,0x0d
0x6c,0x6f,0x63,0x61,0x6c,0x20,0x63,0x6c,0x75,0x73,0x74,0x65,0x72

0x00,0x00,0x00,0x05
0x33,0x2e,0x34,0x2e,0x32

0x00,0x00,0x00,0x0b
0x64,0x61,0x74,0x61,0x63,0x65,0x6e,0x74,0x65,0x72,0x31

0x00,0x00,0x00,0x04
0x00,0x00,0x00,0x00

0x00,0x00,0x00,0x10,0x38,0x7e,0x73,0x4c,0x04,0x68,0x08,0x90,0x28,0x4d,0xa1,0xfa,0xd2,0xad,0x7a,0x6f,0x00,0x00,0x00,0x04,0xc0,0xa8,0x0b,0x3c,0x00,0x00,0x00,0x01,0x34,0x00,0x00,0x00,0x2b,0x6f,0x72,0x67,0x2e,0x61,0x70,0x61,0x63,0x68,0x65,0x2e,0x63,0x61,0x73,0x73,0x61,0x6e,0x64,0x72,0x61,0x2e,0x64,0x68,0x74,0x2e,0x4d,0x75,0x72,0x6d,0x75,0x72,0x33,0x50,0x61,0x72,0x74,0x69,0x74,0x69,0x6f,0x6e,0x65,0x72,0x00,0x00,0x00,0x05,0x72,0x61,0x63,0x6b,0x31,0x00,0x00,0x00,0x0c,0x33,0x2e,0x39,0x2d,0x53,0x4e,0x41,0x50,0x53,0x48,0x4f,0x54,0x00,0x00,0x00,0x04,0xc0,0xa8,0x0b,0x3c,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x32,0x30,0x2e,0x31,0x2e,0x30,0x00,0x00,0x00,0x1b,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x13,0x33,0x36,0x38,0x39,0x30,0x31,0x31,0x30,0x34,0x34,0x37,0x36,0x39,0x38,0x35,0x37,0x35,0x33,0x36,0xff,0xff,0xff,0xff*/

#include <vector>
#include <cstddef>
#include <string>
#include <cstdint>
#include <array>

namespace proxy
    {
        namespace response {
    namespace detail {

        inline void PackBytes(std::vector<unsigned char>& bytes, const std::string& str) {
            std::uint32_t len_be = htobe32(str.size());
            auto len_be_first = static_cast<const unsigned char*>(static_cast<const void*>(&len_be));
            bytes.insert(bytes.end(), len_be_first, len_be_first + sizeof(len_be));

            auto str_first = reinterpret_cast<const unsigned char*>(str.data());
            bytes.insert(bytes.end(), str_first, str_first + str.size());
        }

                inline void PackBytes(std::vector<unsigned char>& bytes, const unsigned char* str) {
            std::uint32_t len_be = htobe32(sizeof(str));
            auto len_be_first = static_cast<const unsigned char*>(static_cast<const void*>(&len_be));
            bytes.insert(bytes.end(), len_be_first, len_be_first + sizeof(len_be));

            // auto str_first = reinterpret_cast<const unsigned char*>(str);
            bytes.insert(bytes.end(), str, str + sizeof(str));
        }

        inline void PackBytes(std::vector<unsigned char>& bytes, int integer) { // columnのバイト列の長さとcolumのデータ
            std::uint32_t len_be = htobe32(4);
            auto len_be_first = static_cast<const unsigned char*>(static_cast<const void*>(&len_be));
            bytes.insert(bytes.end(), len_be_first, len_be_first + sizeof(len_be));

            auto int_first = reinterpret_cast<const unsigned char*>(&integer);
            // int の場合は リトルエンディアン
            auto itr = int_first[0];
            for(int i = 3; i >= 0; i--) {
                bytes.push_back(int_first[i]);
            }
            // bytes.insert(bytes.end(), int_first, int_first + 4);
        }
        
        inline void PackBytes(std::vector<unsigned char>& bytes, float floating) { // columnのバイト列の長さとcolumのデータ
            std::uint32_t len_be = htobe32(4);
            auto len_be_first = static_cast<const unsigned char*>(static_cast<const void*>(&len_be));
            bytes.insert(bytes.end(), len_be_first, len_be_first + sizeof(len_be));

            auto int_first = reinterpret_cast<const unsigned char*>(&floating);
            // int の場合は リトルエンディアン
            auto itr = int_first[0];
            for(int i = 3; i >= 0; i--) {
                bytes.push_back(int_first[i]);
            }
        }

        inline void SetBytes(std::vector<unsigned char>& bytes) {}

        template<class Column, class... Columns>
        void SetBytes(std::vector<unsigned char>& bytes, Column&& column, Columns&&... columns) {
            // pack
            PackBytes(bytes, std::forward<Column>(column));

            SetBytes(bytes, std::forward<Columns>(columns)...);
        }

        template<class ColumnType>
        struct ColumnTypeId;

        template<> struct ColumnTypeId<std::string> {
            static constexpr std::uint16_t value = 0x000d;
        };

        template<> struct ColumnTypeId<int> {
            static constexpr std::uint16_t value = 0x0009;
        };

        template<> struct ColumnTypeId<float> {
            static constexpr std::uint16_t value = 0x0008;
        };

#define INSERT_BYTES4(target, data) do{\
                std::uint32_t _data_tmp_swap_bytes_ = htobe32(data); \
                auto int_first = reinterpret_cast<const unsigned char*>(&_data_tmp_swap_bytes_); \
                target.insert(target.end(), int_first, int_first + 4);\
            }while(0)
#define INSERT_BYTES2(target, data) do{\
                std::uint32_t _data_tmp_swap_bytes_ = htobe16(data); \
                auto int_first = reinterpret_cast<const unsigned char*>(&_data_tmp_swap_bytes_); \
                target.insert(target.end(), int_first, int_first + 2);\
            }while(0)

        template<std::size_t N>
        void SetColumnName(std::vector<unsigned char>& bytes, const std::array<cpp17::string_view, N>& columns, std::size_t current) {
        }
        
        template<std::size_t N, class Column, class... Columns>
        void SetColumnName(std::vector<unsigned char>& bytes, const std::array<cpp17::string_view, N>& columns, std::size_t current) {
            // column 1
            // 0x00,0x03
            //0x6b,0x65,0x79
            //0x00,0x0d  // varchar
            INSERT_BYTES2(bytes, columns[current].size());
            {
                auto str_first = reinterpret_cast<const unsigned char*>(columns[current].data());
                bytes.insert(bytes.end(), str_first, str_first + columns[current].size());
            }
            INSERT_BYTES2(bytes, ColumnTypeId<Column>::value);

            SetColumnName<N, Columns...>(bytes, columns, current + 1);
        }
    }

    template<class... Columns>
    class BasicResult {
    private:
        std::vector<unsigned char> bytes_;

    public:
        BasicResult(cpp17::string_view ks, cpp17::string_view tbl, const std::array<cpp17::string_view, sizeof...(Columns)>& columns, std::uint32_t column_count) { // ヘッダの書き込み
            /*0x00,0x00,0x00,0x02 // Rows
0x00,0x00,0x00,0x01  // flags 1
0x00,0x00,0x00,0x12  // column count
0x00,0x06 // len(ksname)
0x73,0x79,0x73,0x74,0x65,0x6d // ksname
0x00,0x05 // len(tablename)
0x6c,0x6f,0x63,0x61,0x6c // tablename*/
            if (columns.size() != column_count ) {return;} 
            INSERT_BYTES4(bytes_, 2); // Rows
            INSERT_BYTES4(bytes_, 1); // flag
            INSERT_BYTES4(bytes_, columns.size()); // column count

            INSERT_BYTES2(bytes_, ks.size());
            {
                auto str_first = reinterpret_cast<const unsigned char*>(ks.data());
                bytes_.insert(bytes_.end(), str_first, str_first + ks.size());
            }

            INSERT_BYTES2(bytes_, tbl.size());
            {
                auto str_first = reinterpret_cast<const unsigned char*>(tbl.data());
                bytes_.insert(bytes_.end(), str_first, str_first + tbl.size());
            }
            /*
// column 1
0x00,0x03
0x6b,0x65,0x79
0x00,0x0d  // varchar
// column 2
0x00,0x0c
0x62,0x6f,0x6f,0x74,0x73,0x74,0x72,0x61,0x70,0x70,0x65,0x64
0x00,0x0d // varchar
// column 3
0x00,0x11
0x62,0x72,0x6f,0x61,0x64,0x63,0x61,0x73,0x74,0x5f,0x61,0x64,0x64,0x72,0x65,0x73,0x73
0x00,0x10 // Inet
// column 4
0x00,0x0c
0x63,0x6c,0x75,0x73,0x74,0x65,0x72,0x5f,0x6e,0x61,0x6d,0x65
0x00,0x0d // varchar
// column 5
0x00,0x0b
0x63,0x71,0x6c,0x5f,0x76,0x65,0x72,0x73,0x69,0x6f,0x6e
0x00,0x0d // varchar
// column 6
0x00,0x0b
0x64,0x61,0x74,0x61,0x5f,0x63,0x65,0x6e,0x74,0x65,0x72
0x00,0x0d // varchar
// column 7
0x00,0x11
0x67,0x6f,0x73,0x73,0x69,0x70,0x5f,0x67,0x65,0x6e,0x65,0x72,0x61,0x74,0x69,0x6f,0x6e
0x00,0x09 // int*/
            detail::SetColumnName<sizeof...(Columns), Columns...>(bytes_, columns, 0);

            INSERT_BYTES4(bytes_, 1); // Rows count
        }
#undef INSERT_BYTES4
#undef INSERT_BYTES2

    public:
        void addRow(Columns... columns) {
            detail::SetBytes(bytes_, columns...);
        }

        const std::vector<unsigned char>& bytes() const noexcept {return bytes_;}
        std::vector<unsigned char>& bytes() noexcept {return bytes_;}
    };

    using Result = BasicResult<int>;
    using GetCust = BasicResult<float, std::string, std::string>;
    using GetWhse = BasicResult<float>; 
    using GetDist = BasicResult<int, float>; 
    using GetItem = BasicResult<std::string, float, std::string>;
    using GetStock = BasicResult<int, std::string, std::string, std::string, std::string, std::string, std::string, std::string, std::string, std::string, std::string, std::string>;
}
}